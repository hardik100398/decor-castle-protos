"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: ledger.proto
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.LedgerTransactionSummary_TransactionsByMonthEntry = exports.LedgerTransactionSummary_TransactionsByTypeEntry = exports.LedgerTransactionSummary = exports.LedgerAccountSummary_AccountsByTypeEntry = exports.LedgerAccountSummary = exports.UpdateLedgerTransactionRequest = exports.CreateLedgerTransactionRequest = exports.UpdateLedgerAccountRequest = exports.CreateLedgerAccountRequest = exports.LedgerTransaction = exports.LedgerAccount = exports.TransactionType = exports.AccountType = exports.protobufPackage = void 0;
exports.accountTypeFromJSON = accountTypeFromJSON;
exports.accountTypeToJSON = accountTypeToJSON;
exports.transactionTypeFromJSON = transactionTypeFromJSON;
exports.transactionTypeToJSON = transactionTypeToJSON;
/* eslint-disable */
const _m0 = __importStar(require("protobufjs/minimal"));
exports.protobufPackage = "decorcastle";
/** Account types enum */
var AccountType;
(function (AccountType) {
    AccountType[AccountType["CREDITOR"] = 0] = "CREDITOR";
    AccountType[AccountType["DEBTOR"] = 1] = "DEBTOR";
    AccountType[AccountType["CASH"] = 2] = "CASH";
    AccountType[AccountType["BANK"] = 3] = "BANK";
    AccountType[AccountType["EXPENSE"] = 4] = "EXPENSE";
    AccountType[AccountType["INCOME"] = 5] = "INCOME";
    AccountType[AccountType["ASSET"] = 6] = "ASSET";
    AccountType[AccountType["LIABILITY"] = 7] = "LIABILITY";
    AccountType[AccountType["EQUITY"] = 8] = "EQUITY";
    AccountType[AccountType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AccountType || (exports.AccountType = AccountType = {}));
function accountTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "CREDITOR":
            return AccountType.CREDITOR;
        case 1:
        case "DEBTOR":
            return AccountType.DEBTOR;
        case 2:
        case "CASH":
            return AccountType.CASH;
        case 3:
        case "BANK":
            return AccountType.BANK;
        case 4:
        case "EXPENSE":
            return AccountType.EXPENSE;
        case 5:
        case "INCOME":
            return AccountType.INCOME;
        case 6:
        case "ASSET":
            return AccountType.ASSET;
        case 7:
        case "LIABILITY":
            return AccountType.LIABILITY;
        case 8:
        case "EQUITY":
            return AccountType.EQUITY;
        case -1:
        case "UNRECOGNIZED":
        default:
            return AccountType.UNRECOGNIZED;
    }
}
function accountTypeToJSON(object) {
    switch (object) {
        case AccountType.CREDITOR:
            return "CREDITOR";
        case AccountType.DEBTOR:
            return "DEBTOR";
        case AccountType.CASH:
            return "CASH";
        case AccountType.BANK:
            return "BANK";
        case AccountType.EXPENSE:
            return "EXPENSE";
        case AccountType.INCOME:
            return "INCOME";
        case AccountType.ASSET:
            return "ASSET";
        case AccountType.LIABILITY:
            return "LIABILITY";
        case AccountType.EQUITY:
            return "EQUITY";
        case AccountType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
/** Transaction types enum */
var TransactionType;
(function (TransactionType) {
    TransactionType[TransactionType["DEBIT"] = 0] = "DEBIT";
    TransactionType[TransactionType["CREDIT"] = 1] = "CREDIT";
    TransactionType[TransactionType["TRANSFER"] = 2] = "TRANSFER";
    TransactionType[TransactionType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TransactionType || (exports.TransactionType = TransactionType = {}));
function transactionTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "DEBIT":
            return TransactionType.DEBIT;
        case 1:
        case "CREDIT":
            return TransactionType.CREDIT;
        case 2:
        case "TRANSFER":
            return TransactionType.TRANSFER;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TransactionType.UNRECOGNIZED;
    }
}
function transactionTypeToJSON(object) {
    switch (object) {
        case TransactionType.DEBIT:
            return "DEBIT";
        case TransactionType.CREDIT:
            return "CREDIT";
        case TransactionType.TRANSFER:
            return "TRANSFER";
        case TransactionType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseLedgerAccount() {
    return {
        id: 0,
        name: "",
        accountType: 0,
        contact: undefined,
        email: undefined,
        reference: undefined,
        address: undefined,
        openingBalance: 0,
        currentBalance: 0,
        isActive: false,
        isConsignee: false,
        createdAt: "",
        updatedAt: "",
    };
}
exports.LedgerAccount = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== 0) {
            writer.uint32(8).int32(message.id);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.accountType !== 0) {
            writer.uint32(24).int32(message.accountType);
        }
        if (message.contact !== undefined) {
            writer.uint32(34).string(message.contact);
        }
        if (message.email !== undefined) {
            writer.uint32(42).string(message.email);
        }
        if (message.reference !== undefined) {
            writer.uint32(50).string(message.reference);
        }
        if (message.address !== undefined) {
            writer.uint32(58).string(message.address);
        }
        if (message.openingBalance !== 0) {
            writer.uint32(69).float(message.openingBalance);
        }
        if (message.currentBalance !== 0) {
            writer.uint32(77).float(message.currentBalance);
        }
        if (message.isActive !== false) {
            writer.uint32(80).bool(message.isActive);
        }
        if (message.isConsignee !== false) {
            writer.uint32(88).bool(message.isConsignee);
        }
        if (message.createdAt !== "") {
            writer.uint32(98).string(message.createdAt);
        }
        if (message.updatedAt !== "") {
            writer.uint32(106).string(message.updatedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLedgerAccount();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.accountType = reader.int32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.contact = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.email = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.reference = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 8:
                    if (tag !== 69) {
                        break;
                    }
                    message.openingBalance = reader.float();
                    continue;
                case 9:
                    if (tag !== 77) {
                        break;
                    }
                    message.currentBalance = reader.float();
                    continue;
                case 10:
                    if (tag !== 80) {
                        break;
                    }
                    message.isActive = reader.bool();
                    continue;
                case 11:
                    if (tag !== 88) {
                        break;
                    }
                    message.isConsignee = reader.bool();
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.createdAt = reader.string();
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.updatedAt = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.Number(object.id) : 0,
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            accountType: isSet(object.accountType) ? accountTypeFromJSON(object.accountType) : 0,
            contact: isSet(object.contact) ? globalThis.String(object.contact) : undefined,
            email: isSet(object.email) ? globalThis.String(object.email) : undefined,
            reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
            address: isSet(object.address) ? globalThis.String(object.address) : undefined,
            openingBalance: isSet(object.openingBalance) ? globalThis.Number(object.openingBalance) : 0,
            currentBalance: isSet(object.currentBalance) ? globalThis.Number(object.currentBalance) : 0,
            isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
            isConsignee: isSet(object.isConsignee) ? globalThis.Boolean(object.isConsignee) : false,
            createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
            updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0) {
            obj.id = Math.round(message.id);
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.accountType !== 0) {
            obj.accountType = accountTypeToJSON(message.accountType);
        }
        if (message.contact !== undefined) {
            obj.contact = message.contact;
        }
        if (message.email !== undefined) {
            obj.email = message.email;
        }
        if (message.reference !== undefined) {
            obj.reference = message.reference;
        }
        if (message.address !== undefined) {
            obj.address = message.address;
        }
        if (message.openingBalance !== 0) {
            obj.openingBalance = message.openingBalance;
        }
        if (message.currentBalance !== 0) {
            obj.currentBalance = message.currentBalance;
        }
        if (message.isActive !== false) {
            obj.isActive = message.isActive;
        }
        if (message.isConsignee !== false) {
            obj.isConsignee = message.isConsignee;
        }
        if (message.createdAt !== "") {
            obj.createdAt = message.createdAt;
        }
        if (message.updatedAt !== "") {
            obj.updatedAt = message.updatedAt;
        }
        return obj;
    },
    create(base) {
        return exports.LedgerAccount.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const message = createBaseLedgerAccount();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : 0;
        message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
        message.accountType = (_c = object.accountType) !== null && _c !== void 0 ? _c : 0;
        message.contact = (_d = object.contact) !== null && _d !== void 0 ? _d : undefined;
        message.email = (_e = object.email) !== null && _e !== void 0 ? _e : undefined;
        message.reference = (_f = object.reference) !== null && _f !== void 0 ? _f : undefined;
        message.address = (_g = object.address) !== null && _g !== void 0 ? _g : undefined;
        message.openingBalance = (_h = object.openingBalance) !== null && _h !== void 0 ? _h : 0;
        message.currentBalance = (_j = object.currentBalance) !== null && _j !== void 0 ? _j : 0;
        message.isActive = (_k = object.isActive) !== null && _k !== void 0 ? _k : false;
        message.isConsignee = (_l = object.isConsignee) !== null && _l !== void 0 ? _l : false;
        message.createdAt = (_m = object.createdAt) !== null && _m !== void 0 ? _m : "";
        message.updatedAt = (_o = object.updatedAt) !== null && _o !== void 0 ? _o : "";
        return message;
    },
};
function createBaseLedgerTransaction() {
    return {
        id: 0,
        debitAccountId: undefined,
        creditAccountId: undefined,
        amount: 0,
        transactionType: 0,
        description: undefined,
        referenceNumber: undefined,
        voucherNumber: undefined,
        voucherDate: undefined,
        createdAt: "",
        updatedAt: "",
    };
}
exports.LedgerTransaction = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== 0) {
            writer.uint32(8).int32(message.id);
        }
        if (message.debitAccountId !== undefined) {
            writer.uint32(16).int32(message.debitAccountId);
        }
        if (message.creditAccountId !== undefined) {
            writer.uint32(24).int32(message.creditAccountId);
        }
        if (message.amount !== 0) {
            writer.uint32(37).float(message.amount);
        }
        if (message.transactionType !== 0) {
            writer.uint32(40).int32(message.transactionType);
        }
        if (message.description !== undefined) {
            writer.uint32(50).string(message.description);
        }
        if (message.referenceNumber !== undefined) {
            writer.uint32(58).string(message.referenceNumber);
        }
        if (message.voucherNumber !== undefined) {
            writer.uint32(66).string(message.voucherNumber);
        }
        if (message.voucherDate !== undefined) {
            writer.uint32(74).string(message.voucherDate);
        }
        if (message.createdAt !== "") {
            writer.uint32(82).string(message.createdAt);
        }
        if (message.updatedAt !== "") {
            writer.uint32(90).string(message.updatedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLedgerTransaction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.debitAccountId = reader.int32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.creditAccountId = reader.int32();
                    continue;
                case 4:
                    if (tag !== 37) {
                        break;
                    }
                    message.amount = reader.float();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.transactionType = reader.int32();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.referenceNumber = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.voucherNumber = reader.string();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.voucherDate = reader.string();
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.createdAt = reader.string();
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.updatedAt = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.Number(object.id) : 0,
            debitAccountId: isSet(object.debitAccountId) ? globalThis.Number(object.debitAccountId) : undefined,
            creditAccountId: isSet(object.creditAccountId) ? globalThis.Number(object.creditAccountId) : undefined,
            amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
            transactionType: isSet(object.transactionType) ? transactionTypeFromJSON(object.transactionType) : 0,
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
            referenceNumber: isSet(object.referenceNumber) ? globalThis.String(object.referenceNumber) : undefined,
            voucherNumber: isSet(object.voucherNumber) ? globalThis.String(object.voucherNumber) : undefined,
            voucherDate: isSet(object.voucherDate) ? globalThis.String(object.voucherDate) : undefined,
            createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
            updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0) {
            obj.id = Math.round(message.id);
        }
        if (message.debitAccountId !== undefined) {
            obj.debitAccountId = Math.round(message.debitAccountId);
        }
        if (message.creditAccountId !== undefined) {
            obj.creditAccountId = Math.round(message.creditAccountId);
        }
        if (message.amount !== 0) {
            obj.amount = message.amount;
        }
        if (message.transactionType !== 0) {
            obj.transactionType = transactionTypeToJSON(message.transactionType);
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.referenceNumber !== undefined) {
            obj.referenceNumber = message.referenceNumber;
        }
        if (message.voucherNumber !== undefined) {
            obj.voucherNumber = message.voucherNumber;
        }
        if (message.voucherDate !== undefined) {
            obj.voucherDate = message.voucherDate;
        }
        if (message.createdAt !== "") {
            obj.createdAt = message.createdAt;
        }
        if (message.updatedAt !== "") {
            obj.updatedAt = message.updatedAt;
        }
        return obj;
    },
    create(base) {
        return exports.LedgerTransaction.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const message = createBaseLedgerTransaction();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : 0;
        message.debitAccountId = (_b = object.debitAccountId) !== null && _b !== void 0 ? _b : undefined;
        message.creditAccountId = (_c = object.creditAccountId) !== null && _c !== void 0 ? _c : undefined;
        message.amount = (_d = object.amount) !== null && _d !== void 0 ? _d : 0;
        message.transactionType = (_e = object.transactionType) !== null && _e !== void 0 ? _e : 0;
        message.description = (_f = object.description) !== null && _f !== void 0 ? _f : undefined;
        message.referenceNumber = (_g = object.referenceNumber) !== null && _g !== void 0 ? _g : undefined;
        message.voucherNumber = (_h = object.voucherNumber) !== null && _h !== void 0 ? _h : undefined;
        message.voucherDate = (_j = object.voucherDate) !== null && _j !== void 0 ? _j : undefined;
        message.createdAt = (_k = object.createdAt) !== null && _k !== void 0 ? _k : "";
        message.updatedAt = (_l = object.updatedAt) !== null && _l !== void 0 ? _l : "";
        return message;
    },
};
function createBaseCreateLedgerAccountRequest() {
    return {
        name: "",
        accountType: 0,
        contact: undefined,
        email: undefined,
        reference: undefined,
        address: undefined,
        openingBalance: 0,
        isActive: false,
        isConsignee: false,
    };
}
exports.CreateLedgerAccountRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.accountType !== 0) {
            writer.uint32(16).int32(message.accountType);
        }
        if (message.contact !== undefined) {
            writer.uint32(26).string(message.contact);
        }
        if (message.email !== undefined) {
            writer.uint32(34).string(message.email);
        }
        if (message.reference !== undefined) {
            writer.uint32(42).string(message.reference);
        }
        if (message.address !== undefined) {
            writer.uint32(50).string(message.address);
        }
        if (message.openingBalance !== 0) {
            writer.uint32(61).float(message.openingBalance);
        }
        if (message.isActive !== false) {
            writer.uint32(64).bool(message.isActive);
        }
        if (message.isConsignee !== false) {
            writer.uint32(72).bool(message.isConsignee);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateLedgerAccountRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.accountType = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.contact = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.email = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.reference = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 7:
                    if (tag !== 61) {
                        break;
                    }
                    message.openingBalance = reader.float();
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.isActive = reader.bool();
                    continue;
                case 9:
                    if (tag !== 72) {
                        break;
                    }
                    message.isConsignee = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            accountType: isSet(object.accountType) ? accountTypeFromJSON(object.accountType) : 0,
            contact: isSet(object.contact) ? globalThis.String(object.contact) : undefined,
            email: isSet(object.email) ? globalThis.String(object.email) : undefined,
            reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
            address: isSet(object.address) ? globalThis.String(object.address) : undefined,
            openingBalance: isSet(object.openingBalance) ? globalThis.Number(object.openingBalance) : 0,
            isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
            isConsignee: isSet(object.isConsignee) ? globalThis.Boolean(object.isConsignee) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.accountType !== 0) {
            obj.accountType = accountTypeToJSON(message.accountType);
        }
        if (message.contact !== undefined) {
            obj.contact = message.contact;
        }
        if (message.email !== undefined) {
            obj.email = message.email;
        }
        if (message.reference !== undefined) {
            obj.reference = message.reference;
        }
        if (message.address !== undefined) {
            obj.address = message.address;
        }
        if (message.openingBalance !== 0) {
            obj.openingBalance = message.openingBalance;
        }
        if (message.isActive !== false) {
            obj.isActive = message.isActive;
        }
        if (message.isConsignee !== false) {
            obj.isConsignee = message.isConsignee;
        }
        return obj;
    },
    create(base) {
        return exports.CreateLedgerAccountRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = createBaseCreateLedgerAccountRequest();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.accountType = (_b = object.accountType) !== null && _b !== void 0 ? _b : 0;
        message.contact = (_c = object.contact) !== null && _c !== void 0 ? _c : undefined;
        message.email = (_d = object.email) !== null && _d !== void 0 ? _d : undefined;
        message.reference = (_e = object.reference) !== null && _e !== void 0 ? _e : undefined;
        message.address = (_f = object.address) !== null && _f !== void 0 ? _f : undefined;
        message.openingBalance = (_g = object.openingBalance) !== null && _g !== void 0 ? _g : 0;
        message.isActive = (_h = object.isActive) !== null && _h !== void 0 ? _h : false;
        message.isConsignee = (_j = object.isConsignee) !== null && _j !== void 0 ? _j : false;
        return message;
    },
};
function createBaseUpdateLedgerAccountRequest() {
    return {
        name: undefined,
        accountType: undefined,
        contact: undefined,
        email: undefined,
        reference: undefined,
        address: undefined,
        openingBalance: undefined,
        isActive: undefined,
        isConsignee: undefined,
    };
}
exports.UpdateLedgerAccountRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== undefined) {
            writer.uint32(10).string(message.name);
        }
        if (message.accountType !== undefined) {
            writer.uint32(16).int32(message.accountType);
        }
        if (message.contact !== undefined) {
            writer.uint32(26).string(message.contact);
        }
        if (message.email !== undefined) {
            writer.uint32(34).string(message.email);
        }
        if (message.reference !== undefined) {
            writer.uint32(42).string(message.reference);
        }
        if (message.address !== undefined) {
            writer.uint32(50).string(message.address);
        }
        if (message.openingBalance !== undefined) {
            writer.uint32(61).float(message.openingBalance);
        }
        if (message.isActive !== undefined) {
            writer.uint32(64).bool(message.isActive);
        }
        if (message.isConsignee !== undefined) {
            writer.uint32(72).bool(message.isConsignee);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateLedgerAccountRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.accountType = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.contact = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.email = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.reference = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 7:
                    if (tag !== 61) {
                        break;
                    }
                    message.openingBalance = reader.float();
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.isActive = reader.bool();
                    continue;
                case 9:
                    if (tag !== 72) {
                        break;
                    }
                    message.isConsignee = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : undefined,
            accountType: isSet(object.accountType) ? accountTypeFromJSON(object.accountType) : undefined,
            contact: isSet(object.contact) ? globalThis.String(object.contact) : undefined,
            email: isSet(object.email) ? globalThis.String(object.email) : undefined,
            reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
            address: isSet(object.address) ? globalThis.String(object.address) : undefined,
            openingBalance: isSet(object.openingBalance) ? globalThis.Number(object.openingBalance) : undefined,
            isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : undefined,
            isConsignee: isSet(object.isConsignee) ? globalThis.Boolean(object.isConsignee) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        if (message.accountType !== undefined) {
            obj.accountType = accountTypeToJSON(message.accountType);
        }
        if (message.contact !== undefined) {
            obj.contact = message.contact;
        }
        if (message.email !== undefined) {
            obj.email = message.email;
        }
        if (message.reference !== undefined) {
            obj.reference = message.reference;
        }
        if (message.address !== undefined) {
            obj.address = message.address;
        }
        if (message.openingBalance !== undefined) {
            obj.openingBalance = message.openingBalance;
        }
        if (message.isActive !== undefined) {
            obj.isActive = message.isActive;
        }
        if (message.isConsignee !== undefined) {
            obj.isConsignee = message.isConsignee;
        }
        return obj;
    },
    create(base) {
        return exports.UpdateLedgerAccountRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = createBaseUpdateLedgerAccountRequest();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : undefined;
        message.accountType = (_b = object.accountType) !== null && _b !== void 0 ? _b : undefined;
        message.contact = (_c = object.contact) !== null && _c !== void 0 ? _c : undefined;
        message.email = (_d = object.email) !== null && _d !== void 0 ? _d : undefined;
        message.reference = (_e = object.reference) !== null && _e !== void 0 ? _e : undefined;
        message.address = (_f = object.address) !== null && _f !== void 0 ? _f : undefined;
        message.openingBalance = (_g = object.openingBalance) !== null && _g !== void 0 ? _g : undefined;
        message.isActive = (_h = object.isActive) !== null && _h !== void 0 ? _h : undefined;
        message.isConsignee = (_j = object.isConsignee) !== null && _j !== void 0 ? _j : undefined;
        return message;
    },
};
function createBaseCreateLedgerTransactionRequest() {
    return {
        debitAccountId: undefined,
        creditAccountId: undefined,
        amount: 0,
        transactionType: 0,
        description: undefined,
        referenceNumber: undefined,
        voucherNumber: undefined,
        voucherDate: undefined,
    };
}
exports.CreateLedgerTransactionRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.debitAccountId !== undefined) {
            writer.uint32(8).int32(message.debitAccountId);
        }
        if (message.creditAccountId !== undefined) {
            writer.uint32(16).int32(message.creditAccountId);
        }
        if (message.amount !== 0) {
            writer.uint32(29).float(message.amount);
        }
        if (message.transactionType !== 0) {
            writer.uint32(32).int32(message.transactionType);
        }
        if (message.description !== undefined) {
            writer.uint32(42).string(message.description);
        }
        if (message.referenceNumber !== undefined) {
            writer.uint32(50).string(message.referenceNumber);
        }
        if (message.voucherNumber !== undefined) {
            writer.uint32(58).string(message.voucherNumber);
        }
        if (message.voucherDate !== undefined) {
            writer.uint32(66).string(message.voucherDate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateLedgerTransactionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.debitAccountId = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.creditAccountId = reader.int32();
                    continue;
                case 3:
                    if (tag !== 29) {
                        break;
                    }
                    message.amount = reader.float();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.transactionType = reader.int32();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.referenceNumber = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.voucherNumber = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.voucherDate = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            debitAccountId: isSet(object.debitAccountId) ? globalThis.Number(object.debitAccountId) : undefined,
            creditAccountId: isSet(object.creditAccountId) ? globalThis.Number(object.creditAccountId) : undefined,
            amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
            transactionType: isSet(object.transactionType) ? transactionTypeFromJSON(object.transactionType) : 0,
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
            referenceNumber: isSet(object.referenceNumber) ? globalThis.String(object.referenceNumber) : undefined,
            voucherNumber: isSet(object.voucherNumber) ? globalThis.String(object.voucherNumber) : undefined,
            voucherDate: isSet(object.voucherDate) ? globalThis.String(object.voucherDate) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.debitAccountId !== undefined) {
            obj.debitAccountId = Math.round(message.debitAccountId);
        }
        if (message.creditAccountId !== undefined) {
            obj.creditAccountId = Math.round(message.creditAccountId);
        }
        if (message.amount !== 0) {
            obj.amount = message.amount;
        }
        if (message.transactionType !== 0) {
            obj.transactionType = transactionTypeToJSON(message.transactionType);
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.referenceNumber !== undefined) {
            obj.referenceNumber = message.referenceNumber;
        }
        if (message.voucherNumber !== undefined) {
            obj.voucherNumber = message.voucherNumber;
        }
        if (message.voucherDate !== undefined) {
            obj.voucherDate = message.voucherDate;
        }
        return obj;
    },
    create(base) {
        return exports.CreateLedgerTransactionRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseCreateLedgerTransactionRequest();
        message.debitAccountId = (_a = object.debitAccountId) !== null && _a !== void 0 ? _a : undefined;
        message.creditAccountId = (_b = object.creditAccountId) !== null && _b !== void 0 ? _b : undefined;
        message.amount = (_c = object.amount) !== null && _c !== void 0 ? _c : 0;
        message.transactionType = (_d = object.transactionType) !== null && _d !== void 0 ? _d : 0;
        message.description = (_e = object.description) !== null && _e !== void 0 ? _e : undefined;
        message.referenceNumber = (_f = object.referenceNumber) !== null && _f !== void 0 ? _f : undefined;
        message.voucherNumber = (_g = object.voucherNumber) !== null && _g !== void 0 ? _g : undefined;
        message.voucherDate = (_h = object.voucherDate) !== null && _h !== void 0 ? _h : undefined;
        return message;
    },
};
function createBaseUpdateLedgerTransactionRequest() {
    return {
        debitAccountId: undefined,
        creditAccountId: undefined,
        amount: undefined,
        transactionType: undefined,
        description: undefined,
        referenceNumber: undefined,
        voucherNumber: undefined,
        voucherDate: undefined,
    };
}
exports.UpdateLedgerTransactionRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.debitAccountId !== undefined) {
            writer.uint32(8).int32(message.debitAccountId);
        }
        if (message.creditAccountId !== undefined) {
            writer.uint32(16).int32(message.creditAccountId);
        }
        if (message.amount !== undefined) {
            writer.uint32(29).float(message.amount);
        }
        if (message.transactionType !== undefined) {
            writer.uint32(32).int32(message.transactionType);
        }
        if (message.description !== undefined) {
            writer.uint32(42).string(message.description);
        }
        if (message.referenceNumber !== undefined) {
            writer.uint32(50).string(message.referenceNumber);
        }
        if (message.voucherNumber !== undefined) {
            writer.uint32(58).string(message.voucherNumber);
        }
        if (message.voucherDate !== undefined) {
            writer.uint32(66).string(message.voucherDate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateLedgerTransactionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.debitAccountId = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.creditAccountId = reader.int32();
                    continue;
                case 3:
                    if (tag !== 29) {
                        break;
                    }
                    message.amount = reader.float();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.transactionType = reader.int32();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.referenceNumber = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.voucherNumber = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.voucherDate = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            debitAccountId: isSet(object.debitAccountId) ? globalThis.Number(object.debitAccountId) : undefined,
            creditAccountId: isSet(object.creditAccountId) ? globalThis.Number(object.creditAccountId) : undefined,
            amount: isSet(object.amount) ? globalThis.Number(object.amount) : undefined,
            transactionType: isSet(object.transactionType) ? transactionTypeFromJSON(object.transactionType) : undefined,
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
            referenceNumber: isSet(object.referenceNumber) ? globalThis.String(object.referenceNumber) : undefined,
            voucherNumber: isSet(object.voucherNumber) ? globalThis.String(object.voucherNumber) : undefined,
            voucherDate: isSet(object.voucherDate) ? globalThis.String(object.voucherDate) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.debitAccountId !== undefined) {
            obj.debitAccountId = Math.round(message.debitAccountId);
        }
        if (message.creditAccountId !== undefined) {
            obj.creditAccountId = Math.round(message.creditAccountId);
        }
        if (message.amount !== undefined) {
            obj.amount = message.amount;
        }
        if (message.transactionType !== undefined) {
            obj.transactionType = transactionTypeToJSON(message.transactionType);
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.referenceNumber !== undefined) {
            obj.referenceNumber = message.referenceNumber;
        }
        if (message.voucherNumber !== undefined) {
            obj.voucherNumber = message.voucherNumber;
        }
        if (message.voucherDate !== undefined) {
            obj.voucherDate = message.voucherDate;
        }
        return obj;
    },
    create(base) {
        return exports.UpdateLedgerTransactionRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseUpdateLedgerTransactionRequest();
        message.debitAccountId = (_a = object.debitAccountId) !== null && _a !== void 0 ? _a : undefined;
        message.creditAccountId = (_b = object.creditAccountId) !== null && _b !== void 0 ? _b : undefined;
        message.amount = (_c = object.amount) !== null && _c !== void 0 ? _c : undefined;
        message.transactionType = (_d = object.transactionType) !== null && _d !== void 0 ? _d : undefined;
        message.description = (_e = object.description) !== null && _e !== void 0 ? _e : undefined;
        message.referenceNumber = (_f = object.referenceNumber) !== null && _f !== void 0 ? _f : undefined;
        message.voucherNumber = (_g = object.voucherNumber) !== null && _g !== void 0 ? _g : undefined;
        message.voucherDate = (_h = object.voucherDate) !== null && _h !== void 0 ? _h : undefined;
        return message;
    },
};
function createBaseLedgerAccountSummary() {
    return {
        totalAccounts: 0,
        accountsByType: {},
        totalDebitBalance: 0,
        totalCreditBalance: 0,
        activeAccounts: 0,
        inactiveAccounts: 0,
    };
}
exports.LedgerAccountSummary = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.totalAccounts !== 0) {
            writer.uint32(8).int32(message.totalAccounts);
        }
        Object.entries(message.accountsByType).forEach(([key, value]) => {
            exports.LedgerAccountSummary_AccountsByTypeEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.totalDebitBalance !== 0) {
            writer.uint32(29).float(message.totalDebitBalance);
        }
        if (message.totalCreditBalance !== 0) {
            writer.uint32(37).float(message.totalCreditBalance);
        }
        if (message.activeAccounts !== 0) {
            writer.uint32(40).int32(message.activeAccounts);
        }
        if (message.inactiveAccounts !== 0) {
            writer.uint32(48).int32(message.inactiveAccounts);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLedgerAccountSummary();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.totalAccounts = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = exports.LedgerAccountSummary_AccountsByTypeEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.accountsByType[entry2.key] = entry2.value;
                    }
                    continue;
                case 3:
                    if (tag !== 29) {
                        break;
                    }
                    message.totalDebitBalance = reader.float();
                    continue;
                case 4:
                    if (tag !== 37) {
                        break;
                    }
                    message.totalCreditBalance = reader.float();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.activeAccounts = reader.int32();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.inactiveAccounts = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            totalAccounts: isSet(object.totalAccounts) ? globalThis.Number(object.totalAccounts) : 0,
            accountsByType: isObject(object.accountsByType)
                ? Object.entries(object.accountsByType).reduce((acc, [key, value]) => {
                    acc[key] = Number(value);
                    return acc;
                }, {})
                : {},
            totalDebitBalance: isSet(object.totalDebitBalance) ? globalThis.Number(object.totalDebitBalance) : 0,
            totalCreditBalance: isSet(object.totalCreditBalance) ? globalThis.Number(object.totalCreditBalance) : 0,
            activeAccounts: isSet(object.activeAccounts) ? globalThis.Number(object.activeAccounts) : 0,
            inactiveAccounts: isSet(object.inactiveAccounts) ? globalThis.Number(object.inactiveAccounts) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.totalAccounts !== 0) {
            obj.totalAccounts = Math.round(message.totalAccounts);
        }
        if (message.accountsByType) {
            const entries = Object.entries(message.accountsByType);
            if (entries.length > 0) {
                obj.accountsByType = {};
                entries.forEach(([k, v]) => {
                    obj.accountsByType[k] = Math.round(v);
                });
            }
        }
        if (message.totalDebitBalance !== 0) {
            obj.totalDebitBalance = message.totalDebitBalance;
        }
        if (message.totalCreditBalance !== 0) {
            obj.totalCreditBalance = message.totalCreditBalance;
        }
        if (message.activeAccounts !== 0) {
            obj.activeAccounts = Math.round(message.activeAccounts);
        }
        if (message.inactiveAccounts !== 0) {
            obj.inactiveAccounts = Math.round(message.inactiveAccounts);
        }
        return obj;
    },
    create(base) {
        return exports.LedgerAccountSummary.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseLedgerAccountSummary();
        message.totalAccounts = (_a = object.totalAccounts) !== null && _a !== void 0 ? _a : 0;
        message.accountsByType = Object.entries((_b = object.accountsByType) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.Number(value);
            }
            return acc;
        }, {});
        message.totalDebitBalance = (_c = object.totalDebitBalance) !== null && _c !== void 0 ? _c : 0;
        message.totalCreditBalance = (_d = object.totalCreditBalance) !== null && _d !== void 0 ? _d : 0;
        message.activeAccounts = (_e = object.activeAccounts) !== null && _e !== void 0 ? _e : 0;
        message.inactiveAccounts = (_f = object.inactiveAccounts) !== null && _f !== void 0 ? _f : 0;
        return message;
    },
};
function createBaseLedgerAccountSummary_AccountsByTypeEntry() {
    return { key: "", value: 0 };
}
exports.LedgerAccountSummary_AccountsByTypeEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLedgerAccountSummary_AccountsByTypeEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.value = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.Number(object.value) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== 0) {
            obj.value = Math.round(message.value);
        }
        return obj;
    },
    create(base) {
        return exports.LedgerAccountSummary_AccountsByTypeEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLedgerAccountSummary_AccountsByTypeEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseLedgerTransactionSummary() {
    return {
        totalTransactions: 0,
        totalDebitAmount: 0,
        totalCreditAmount: 0,
        transactionsByType: {},
        transactionsByMonth: {},
    };
}
exports.LedgerTransactionSummary = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.totalTransactions !== 0) {
            writer.uint32(8).int32(message.totalTransactions);
        }
        if (message.totalDebitAmount !== 0) {
            writer.uint32(21).float(message.totalDebitAmount);
        }
        if (message.totalCreditAmount !== 0) {
            writer.uint32(29).float(message.totalCreditAmount);
        }
        Object.entries(message.transactionsByType).forEach(([key, value]) => {
            exports.LedgerTransactionSummary_TransactionsByTypeEntry.encode({ key: key, value }, writer.uint32(34).fork())
                .ldelim();
        });
        Object.entries(message.transactionsByMonth).forEach(([key, value]) => {
            exports.LedgerTransactionSummary_TransactionsByMonthEntry.encode({ key: key, value }, writer.uint32(42).fork())
                .ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLedgerTransactionSummary();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.totalTransactions = reader.int32();
                    continue;
                case 2:
                    if (tag !== 21) {
                        break;
                    }
                    message.totalDebitAmount = reader.float();
                    continue;
                case 3:
                    if (tag !== 29) {
                        break;
                    }
                    message.totalCreditAmount = reader.float();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    const entry4 = exports.LedgerTransactionSummary_TransactionsByTypeEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.transactionsByType[entry4.key] = entry4.value;
                    }
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    const entry5 = exports.LedgerTransactionSummary_TransactionsByMonthEntry.decode(reader, reader.uint32());
                    if (entry5.value !== undefined) {
                        message.transactionsByMonth[entry5.key] = entry5.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            totalTransactions: isSet(object.totalTransactions) ? globalThis.Number(object.totalTransactions) : 0,
            totalDebitAmount: isSet(object.totalDebitAmount) ? globalThis.Number(object.totalDebitAmount) : 0,
            totalCreditAmount: isSet(object.totalCreditAmount) ? globalThis.Number(object.totalCreditAmount) : 0,
            transactionsByType: isObject(object.transactionsByType)
                ? Object.entries(object.transactionsByType).reduce((acc, [key, value]) => {
                    acc[key] = Number(value);
                    return acc;
                }, {})
                : {},
            transactionsByMonth: isObject(object.transactionsByMonth)
                ? Object.entries(object.transactionsByMonth).reduce((acc, [key, value]) => {
                    acc[key] = Number(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.totalTransactions !== 0) {
            obj.totalTransactions = Math.round(message.totalTransactions);
        }
        if (message.totalDebitAmount !== 0) {
            obj.totalDebitAmount = message.totalDebitAmount;
        }
        if (message.totalCreditAmount !== 0) {
            obj.totalCreditAmount = message.totalCreditAmount;
        }
        if (message.transactionsByType) {
            const entries = Object.entries(message.transactionsByType);
            if (entries.length > 0) {
                obj.transactionsByType = {};
                entries.forEach(([k, v]) => {
                    obj.transactionsByType[k] = Math.round(v);
                });
            }
        }
        if (message.transactionsByMonth) {
            const entries = Object.entries(message.transactionsByMonth);
            if (entries.length > 0) {
                obj.transactionsByMonth = {};
                entries.forEach(([k, v]) => {
                    obj.transactionsByMonth[k] = Math.round(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return exports.LedgerTransactionSummary.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseLedgerTransactionSummary();
        message.totalTransactions = (_a = object.totalTransactions) !== null && _a !== void 0 ? _a : 0;
        message.totalDebitAmount = (_b = object.totalDebitAmount) !== null && _b !== void 0 ? _b : 0;
        message.totalCreditAmount = (_c = object.totalCreditAmount) !== null && _c !== void 0 ? _c : 0;
        message.transactionsByType = Object.entries((_d = object.transactionsByType) !== null && _d !== void 0 ? _d : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.Number(value);
            }
            return acc;
        }, {});
        message.transactionsByMonth = Object.entries((_e = object.transactionsByMonth) !== null && _e !== void 0 ? _e : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.Number(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseLedgerTransactionSummary_TransactionsByTypeEntry() {
    return { key: "", value: 0 };
}
exports.LedgerTransactionSummary_TransactionsByTypeEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLedgerTransactionSummary_TransactionsByTypeEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.value = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.Number(object.value) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== 0) {
            obj.value = Math.round(message.value);
        }
        return obj;
    },
    create(base) {
        return exports.LedgerTransactionSummary_TransactionsByTypeEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLedgerTransactionSummary_TransactionsByTypeEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseLedgerTransactionSummary_TransactionsByMonthEntry() {
    return { key: "", value: 0 };
}
exports.LedgerTransactionSummary_TransactionsByMonthEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLedgerTransactionSummary_TransactionsByMonthEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.value = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.Number(object.value) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== 0) {
            obj.value = Math.round(message.value);
        }
        return obj;
    },
    create(base) {
        return exports.LedgerTransactionSummary_TransactionsByMonthEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLedgerTransactionSummary_TransactionsByMonthEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
