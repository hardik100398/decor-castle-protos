// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: ledger.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";

export const protobufPackage = "decorcastle";

/** Account types enum */
export enum AccountType {
  CREDITOR = 0,
  DEBTOR = 1,
  CASH = 2,
  BANK = 3,
  EXPENSE = 4,
  INCOME = 5,
  ASSET = 6,
  LIABILITY = 7,
  EQUITY = 8,
  UNRECOGNIZED = -1,
}

export function accountTypeFromJSON(object: any): AccountType {
  switch (object) {
    case 0:
    case "CREDITOR":
      return AccountType.CREDITOR;
    case 1:
    case "DEBTOR":
      return AccountType.DEBTOR;
    case 2:
    case "CASH":
      return AccountType.CASH;
    case 3:
    case "BANK":
      return AccountType.BANK;
    case 4:
    case "EXPENSE":
      return AccountType.EXPENSE;
    case 5:
    case "INCOME":
      return AccountType.INCOME;
    case 6:
    case "ASSET":
      return AccountType.ASSET;
    case 7:
    case "LIABILITY":
      return AccountType.LIABILITY;
    case 8:
    case "EQUITY":
      return AccountType.EQUITY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccountType.UNRECOGNIZED;
  }
}

export function accountTypeToJSON(object: AccountType): string {
  switch (object) {
    case AccountType.CREDITOR:
      return "CREDITOR";
    case AccountType.DEBTOR:
      return "DEBTOR";
    case AccountType.CASH:
      return "CASH";
    case AccountType.BANK:
      return "BANK";
    case AccountType.EXPENSE:
      return "EXPENSE";
    case AccountType.INCOME:
      return "INCOME";
    case AccountType.ASSET:
      return "ASSET";
    case AccountType.LIABILITY:
      return "LIABILITY";
    case AccountType.EQUITY:
      return "EQUITY";
    case AccountType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Transaction types enum */
export enum TransactionType {
  DEBIT = 0,
  CREDIT = 1,
  TRANSFER = 2,
  UNRECOGNIZED = -1,
}

export function transactionTypeFromJSON(object: any): TransactionType {
  switch (object) {
    case 0:
    case "DEBIT":
      return TransactionType.DEBIT;
    case 1:
    case "CREDIT":
      return TransactionType.CREDIT;
    case 2:
    case "TRANSFER":
      return TransactionType.TRANSFER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionType.UNRECOGNIZED;
  }
}

export function transactionTypeToJSON(object: TransactionType): string {
  switch (object) {
    case TransactionType.DEBIT:
      return "DEBIT";
    case TransactionType.CREDIT:
      return "CREDIT";
    case TransactionType.TRANSFER:
      return "TRANSFER";
    case TransactionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Ledger Account message */
export interface LedgerAccount {
  id: number;
  name: string;
  accountType: AccountType;
  contact?: string | undefined;
  email?: string | undefined;
  reference?: string | undefined;
  address?: string | undefined;
  openingBalance: number;
  currentBalance: number;
  isActive: boolean;
  isConsignee: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Ledger Transaction message */
export interface LedgerTransaction {
  id: number;
  debitAccountId?: number | undefined;
  creditAccountId?: number | undefined;
  amount: number;
  transactionType: TransactionType;
  description?: string | undefined;
  referenceNumber?: string | undefined;
  voucherNumber?: string | undefined;
  voucherDate?: string | undefined;
  createdAt: string;
  updatedAt: string;
}

/** Create Ledger Account Request */
export interface CreateLedgerAccountRequest {
  name: string;
  accountType: AccountType;
  contact?: string | undefined;
  email?: string | undefined;
  reference?: string | undefined;
  address?: string | undefined;
  openingBalance: number;
  isActive: boolean;
  isConsignee: boolean;
}

/** Update Ledger Account Request */
export interface UpdateLedgerAccountRequest {
  name?: string | undefined;
  accountType?: AccountType | undefined;
  contact?: string | undefined;
  email?: string | undefined;
  reference?: string | undefined;
  address?: string | undefined;
  openingBalance?: number | undefined;
  isActive?: boolean | undefined;
  isConsignee?: boolean | undefined;
}

/** Create Ledger Transaction Request */
export interface CreateLedgerTransactionRequest {
  debitAccountId?: number | undefined;
  creditAccountId?: number | undefined;
  amount: number;
  transactionType: TransactionType;
  description?: string | undefined;
  referenceNumber?: string | undefined;
  voucherNumber?: string | undefined;
  voucherDate?: string | undefined;
}

/** Update Ledger Transaction Request */
export interface UpdateLedgerTransactionRequest {
  debitAccountId?: number | undefined;
  creditAccountId?: number | undefined;
  amount?: number | undefined;
  transactionType?: TransactionType | undefined;
  description?: string | undefined;
  referenceNumber?: string | undefined;
  voucherNumber?: string | undefined;
  voucherDate?: string | undefined;
}

/** Ledger Account Summary */
export interface LedgerAccountSummary {
  totalAccounts: number;
  accountsByType: { [key: string]: number };
  totalDebitBalance: number;
  totalCreditBalance: number;
  activeAccounts: number;
  inactiveAccounts: number;
}

export interface LedgerAccountSummary_AccountsByTypeEntry {
  key: string;
  value: number;
}

/** Ledger Transaction Summary */
export interface LedgerTransactionSummary {
  totalTransactions: number;
  totalDebitAmount: number;
  totalCreditAmount: number;
  transactionsByType: { [key: string]: number };
  transactionsByMonth: { [key: string]: number };
}

export interface LedgerTransactionSummary_TransactionsByTypeEntry {
  key: string;
  value: number;
}

export interface LedgerTransactionSummary_TransactionsByMonthEntry {
  key: string;
  value: number;
}

function createBaseLedgerAccount(): LedgerAccount {
  return {
    id: 0,
    name: "",
    accountType: 0,
    contact: undefined,
    email: undefined,
    reference: undefined,
    address: undefined,
    openingBalance: 0,
    currentBalance: 0,
    isActive: false,
    isConsignee: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const LedgerAccount = {
  encode(message: LedgerAccount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.accountType !== 0) {
      writer.uint32(24).int32(message.accountType);
    }
    if (message.contact !== undefined) {
      writer.uint32(34).string(message.contact);
    }
    if (message.email !== undefined) {
      writer.uint32(42).string(message.email);
    }
    if (message.reference !== undefined) {
      writer.uint32(50).string(message.reference);
    }
    if (message.address !== undefined) {
      writer.uint32(58).string(message.address);
    }
    if (message.openingBalance !== 0) {
      writer.uint32(69).float(message.openingBalance);
    }
    if (message.currentBalance !== 0) {
      writer.uint32(77).float(message.currentBalance);
    }
    if (message.isActive !== false) {
      writer.uint32(80).bool(message.isActive);
    }
    if (message.isConsignee !== false) {
      writer.uint32(88).bool(message.isConsignee);
    }
    if (message.createdAt !== "") {
      writer.uint32(98).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(106).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LedgerAccount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.accountType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contact = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.email = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.reference = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.address = reader.string();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.openingBalance = reader.float();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.currentBalance = reader.float();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.isConsignee = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerAccount {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      accountType: isSet(object.accountType) ? accountTypeFromJSON(object.accountType) : 0,
      contact: isSet(object.contact) ? globalThis.String(object.contact) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
      address: isSet(object.address) ? globalThis.String(object.address) : undefined,
      openingBalance: isSet(object.openingBalance) ? globalThis.Number(object.openingBalance) : 0,
      currentBalance: isSet(object.currentBalance) ? globalThis.Number(object.currentBalance) : 0,
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      isConsignee: isSet(object.isConsignee) ? globalThis.Boolean(object.isConsignee) : false,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: LedgerAccount): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.accountType !== 0) {
      obj.accountType = accountTypeToJSON(message.accountType);
    }
    if (message.contact !== undefined) {
      obj.contact = message.contact;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.openingBalance !== 0) {
      obj.openingBalance = message.openingBalance;
    }
    if (message.currentBalance !== 0) {
      obj.currentBalance = message.currentBalance;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.isConsignee !== false) {
      obj.isConsignee = message.isConsignee;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedgerAccount>, I>>(base?: I): LedgerAccount {
    return LedgerAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedgerAccount>, I>>(object: I): LedgerAccount {
    const message = createBaseLedgerAccount();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.accountType = object.accountType ?? 0;
    message.contact = object.contact ?? undefined;
    message.email = object.email ?? undefined;
    message.reference = object.reference ?? undefined;
    message.address = object.address ?? undefined;
    message.openingBalance = object.openingBalance ?? 0;
    message.currentBalance = object.currentBalance ?? 0;
    message.isActive = object.isActive ?? false;
    message.isConsignee = object.isConsignee ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseLedgerTransaction(): LedgerTransaction {
  return {
    id: 0,
    debitAccountId: undefined,
    creditAccountId: undefined,
    amount: 0,
    transactionType: 0,
    description: undefined,
    referenceNumber: undefined,
    voucherNumber: undefined,
    voucherDate: undefined,
    createdAt: "",
    updatedAt: "",
  };
}

export const LedgerTransaction = {
  encode(message: LedgerTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.debitAccountId !== undefined) {
      writer.uint32(16).int32(message.debitAccountId);
    }
    if (message.creditAccountId !== undefined) {
      writer.uint32(24).int32(message.creditAccountId);
    }
    if (message.amount !== 0) {
      writer.uint32(37).float(message.amount);
    }
    if (message.transactionType !== 0) {
      writer.uint32(40).int32(message.transactionType);
    }
    if (message.description !== undefined) {
      writer.uint32(50).string(message.description);
    }
    if (message.referenceNumber !== undefined) {
      writer.uint32(58).string(message.referenceNumber);
    }
    if (message.voucherNumber !== undefined) {
      writer.uint32(66).string(message.voucherNumber);
    }
    if (message.voucherDate !== undefined) {
      writer.uint32(74).string(message.voucherDate);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LedgerTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.debitAccountId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.creditAccountId = reader.int32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.amount = reader.float();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.transactionType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.referenceNumber = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.voucherNumber = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.voucherDate = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerTransaction {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      debitAccountId: isSet(object.debitAccountId) ? globalThis.Number(object.debitAccountId) : undefined,
      creditAccountId: isSet(object.creditAccountId) ? globalThis.Number(object.creditAccountId) : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      transactionType: isSet(object.transactionType) ? transactionTypeFromJSON(object.transactionType) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      referenceNumber: isSet(object.referenceNumber) ? globalThis.String(object.referenceNumber) : undefined,
      voucherNumber: isSet(object.voucherNumber) ? globalThis.String(object.voucherNumber) : undefined,
      voucherDate: isSet(object.voucherDate) ? globalThis.String(object.voucherDate) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: LedgerTransaction): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.debitAccountId !== undefined) {
      obj.debitAccountId = Math.round(message.debitAccountId);
    }
    if (message.creditAccountId !== undefined) {
      obj.creditAccountId = Math.round(message.creditAccountId);
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.transactionType !== 0) {
      obj.transactionType = transactionTypeToJSON(message.transactionType);
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.referenceNumber !== undefined) {
      obj.referenceNumber = message.referenceNumber;
    }
    if (message.voucherNumber !== undefined) {
      obj.voucherNumber = message.voucherNumber;
    }
    if (message.voucherDate !== undefined) {
      obj.voucherDate = message.voucherDate;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedgerTransaction>, I>>(base?: I): LedgerTransaction {
    return LedgerTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedgerTransaction>, I>>(object: I): LedgerTransaction {
    const message = createBaseLedgerTransaction();
    message.id = object.id ?? 0;
    message.debitAccountId = object.debitAccountId ?? undefined;
    message.creditAccountId = object.creditAccountId ?? undefined;
    message.amount = object.amount ?? 0;
    message.transactionType = object.transactionType ?? 0;
    message.description = object.description ?? undefined;
    message.referenceNumber = object.referenceNumber ?? undefined;
    message.voucherNumber = object.voucherNumber ?? undefined;
    message.voucherDate = object.voucherDate ?? undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseCreateLedgerAccountRequest(): CreateLedgerAccountRequest {
  return {
    name: "",
    accountType: 0,
    contact: undefined,
    email: undefined,
    reference: undefined,
    address: undefined,
    openingBalance: 0,
    isActive: false,
    isConsignee: false,
  };
}

export const CreateLedgerAccountRequest = {
  encode(message: CreateLedgerAccountRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.accountType !== 0) {
      writer.uint32(16).int32(message.accountType);
    }
    if (message.contact !== undefined) {
      writer.uint32(26).string(message.contact);
    }
    if (message.email !== undefined) {
      writer.uint32(34).string(message.email);
    }
    if (message.reference !== undefined) {
      writer.uint32(42).string(message.reference);
    }
    if (message.address !== undefined) {
      writer.uint32(50).string(message.address);
    }
    if (message.openingBalance !== 0) {
      writer.uint32(61).float(message.openingBalance);
    }
    if (message.isActive !== false) {
      writer.uint32(64).bool(message.isActive);
    }
    if (message.isConsignee !== false) {
      writer.uint32(72).bool(message.isConsignee);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateLedgerAccountRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateLedgerAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.accountType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contact = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.reference = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.address = reader.string();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.openingBalance = reader.float();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isConsignee = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateLedgerAccountRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      accountType: isSet(object.accountType) ? accountTypeFromJSON(object.accountType) : 0,
      contact: isSet(object.contact) ? globalThis.String(object.contact) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
      address: isSet(object.address) ? globalThis.String(object.address) : undefined,
      openingBalance: isSet(object.openingBalance) ? globalThis.Number(object.openingBalance) : 0,
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      isConsignee: isSet(object.isConsignee) ? globalThis.Boolean(object.isConsignee) : false,
    };
  },

  toJSON(message: CreateLedgerAccountRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.accountType !== 0) {
      obj.accountType = accountTypeToJSON(message.accountType);
    }
    if (message.contact !== undefined) {
      obj.contact = message.contact;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.openingBalance !== 0) {
      obj.openingBalance = message.openingBalance;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.isConsignee !== false) {
      obj.isConsignee = message.isConsignee;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateLedgerAccountRequest>, I>>(base?: I): CreateLedgerAccountRequest {
    return CreateLedgerAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateLedgerAccountRequest>, I>>(object: I): CreateLedgerAccountRequest {
    const message = createBaseCreateLedgerAccountRequest();
    message.name = object.name ?? "";
    message.accountType = object.accountType ?? 0;
    message.contact = object.contact ?? undefined;
    message.email = object.email ?? undefined;
    message.reference = object.reference ?? undefined;
    message.address = object.address ?? undefined;
    message.openingBalance = object.openingBalance ?? 0;
    message.isActive = object.isActive ?? false;
    message.isConsignee = object.isConsignee ?? false;
    return message;
  },
};

function createBaseUpdateLedgerAccountRequest(): UpdateLedgerAccountRequest {
  return {
    name: undefined,
    accountType: undefined,
    contact: undefined,
    email: undefined,
    reference: undefined,
    address: undefined,
    openingBalance: undefined,
    isActive: undefined,
    isConsignee: undefined,
  };
}

export const UpdateLedgerAccountRequest = {
  encode(message: UpdateLedgerAccountRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.accountType !== undefined) {
      writer.uint32(16).int32(message.accountType);
    }
    if (message.contact !== undefined) {
      writer.uint32(26).string(message.contact);
    }
    if (message.email !== undefined) {
      writer.uint32(34).string(message.email);
    }
    if (message.reference !== undefined) {
      writer.uint32(42).string(message.reference);
    }
    if (message.address !== undefined) {
      writer.uint32(50).string(message.address);
    }
    if (message.openingBalance !== undefined) {
      writer.uint32(61).float(message.openingBalance);
    }
    if (message.isActive !== undefined) {
      writer.uint32(64).bool(message.isActive);
    }
    if (message.isConsignee !== undefined) {
      writer.uint32(72).bool(message.isConsignee);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateLedgerAccountRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateLedgerAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.accountType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contact = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.reference = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.address = reader.string();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.openingBalance = reader.float();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isConsignee = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateLedgerAccountRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      accountType: isSet(object.accountType) ? accountTypeFromJSON(object.accountType) : undefined,
      contact: isSet(object.contact) ? globalThis.String(object.contact) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
      address: isSet(object.address) ? globalThis.String(object.address) : undefined,
      openingBalance: isSet(object.openingBalance) ? globalThis.Number(object.openingBalance) : undefined,
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : undefined,
      isConsignee: isSet(object.isConsignee) ? globalThis.Boolean(object.isConsignee) : undefined,
    };
  },

  toJSON(message: UpdateLedgerAccountRequest): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.accountType !== undefined) {
      obj.accountType = accountTypeToJSON(message.accountType);
    }
    if (message.contact !== undefined) {
      obj.contact = message.contact;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.openingBalance !== undefined) {
      obj.openingBalance = message.openingBalance;
    }
    if (message.isActive !== undefined) {
      obj.isActive = message.isActive;
    }
    if (message.isConsignee !== undefined) {
      obj.isConsignee = message.isConsignee;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateLedgerAccountRequest>, I>>(base?: I): UpdateLedgerAccountRequest {
    return UpdateLedgerAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateLedgerAccountRequest>, I>>(object: I): UpdateLedgerAccountRequest {
    const message = createBaseUpdateLedgerAccountRequest();
    message.name = object.name ?? undefined;
    message.accountType = object.accountType ?? undefined;
    message.contact = object.contact ?? undefined;
    message.email = object.email ?? undefined;
    message.reference = object.reference ?? undefined;
    message.address = object.address ?? undefined;
    message.openingBalance = object.openingBalance ?? undefined;
    message.isActive = object.isActive ?? undefined;
    message.isConsignee = object.isConsignee ?? undefined;
    return message;
  },
};

function createBaseCreateLedgerTransactionRequest(): CreateLedgerTransactionRequest {
  return {
    debitAccountId: undefined,
    creditAccountId: undefined,
    amount: 0,
    transactionType: 0,
    description: undefined,
    referenceNumber: undefined,
    voucherNumber: undefined,
    voucherDate: undefined,
  };
}

export const CreateLedgerTransactionRequest = {
  encode(message: CreateLedgerTransactionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.debitAccountId !== undefined) {
      writer.uint32(8).int32(message.debitAccountId);
    }
    if (message.creditAccountId !== undefined) {
      writer.uint32(16).int32(message.creditAccountId);
    }
    if (message.amount !== 0) {
      writer.uint32(29).float(message.amount);
    }
    if (message.transactionType !== 0) {
      writer.uint32(32).int32(message.transactionType);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.referenceNumber !== undefined) {
      writer.uint32(50).string(message.referenceNumber);
    }
    if (message.voucherNumber !== undefined) {
      writer.uint32(58).string(message.voucherNumber);
    }
    if (message.voucherDate !== undefined) {
      writer.uint32(66).string(message.voucherDate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateLedgerTransactionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateLedgerTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.debitAccountId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.creditAccountId = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.amount = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.transactionType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.referenceNumber = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.voucherNumber = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.voucherDate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateLedgerTransactionRequest {
    return {
      debitAccountId: isSet(object.debitAccountId) ? globalThis.Number(object.debitAccountId) : undefined,
      creditAccountId: isSet(object.creditAccountId) ? globalThis.Number(object.creditAccountId) : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      transactionType: isSet(object.transactionType) ? transactionTypeFromJSON(object.transactionType) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      referenceNumber: isSet(object.referenceNumber) ? globalThis.String(object.referenceNumber) : undefined,
      voucherNumber: isSet(object.voucherNumber) ? globalThis.String(object.voucherNumber) : undefined,
      voucherDate: isSet(object.voucherDate) ? globalThis.String(object.voucherDate) : undefined,
    };
  },

  toJSON(message: CreateLedgerTransactionRequest): unknown {
    const obj: any = {};
    if (message.debitAccountId !== undefined) {
      obj.debitAccountId = Math.round(message.debitAccountId);
    }
    if (message.creditAccountId !== undefined) {
      obj.creditAccountId = Math.round(message.creditAccountId);
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.transactionType !== 0) {
      obj.transactionType = transactionTypeToJSON(message.transactionType);
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.referenceNumber !== undefined) {
      obj.referenceNumber = message.referenceNumber;
    }
    if (message.voucherNumber !== undefined) {
      obj.voucherNumber = message.voucherNumber;
    }
    if (message.voucherDate !== undefined) {
      obj.voucherDate = message.voucherDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateLedgerTransactionRequest>, I>>(base?: I): CreateLedgerTransactionRequest {
    return CreateLedgerTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateLedgerTransactionRequest>, I>>(
    object: I,
  ): CreateLedgerTransactionRequest {
    const message = createBaseCreateLedgerTransactionRequest();
    message.debitAccountId = object.debitAccountId ?? undefined;
    message.creditAccountId = object.creditAccountId ?? undefined;
    message.amount = object.amount ?? 0;
    message.transactionType = object.transactionType ?? 0;
    message.description = object.description ?? undefined;
    message.referenceNumber = object.referenceNumber ?? undefined;
    message.voucherNumber = object.voucherNumber ?? undefined;
    message.voucherDate = object.voucherDate ?? undefined;
    return message;
  },
};

function createBaseUpdateLedgerTransactionRequest(): UpdateLedgerTransactionRequest {
  return {
    debitAccountId: undefined,
    creditAccountId: undefined,
    amount: undefined,
    transactionType: undefined,
    description: undefined,
    referenceNumber: undefined,
    voucherNumber: undefined,
    voucherDate: undefined,
  };
}

export const UpdateLedgerTransactionRequest = {
  encode(message: UpdateLedgerTransactionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.debitAccountId !== undefined) {
      writer.uint32(8).int32(message.debitAccountId);
    }
    if (message.creditAccountId !== undefined) {
      writer.uint32(16).int32(message.creditAccountId);
    }
    if (message.amount !== undefined) {
      writer.uint32(29).float(message.amount);
    }
    if (message.transactionType !== undefined) {
      writer.uint32(32).int32(message.transactionType);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.referenceNumber !== undefined) {
      writer.uint32(50).string(message.referenceNumber);
    }
    if (message.voucherNumber !== undefined) {
      writer.uint32(58).string(message.voucherNumber);
    }
    if (message.voucherDate !== undefined) {
      writer.uint32(66).string(message.voucherDate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateLedgerTransactionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateLedgerTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.debitAccountId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.creditAccountId = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.amount = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.transactionType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.referenceNumber = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.voucherNumber = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.voucherDate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateLedgerTransactionRequest {
    return {
      debitAccountId: isSet(object.debitAccountId) ? globalThis.Number(object.debitAccountId) : undefined,
      creditAccountId: isSet(object.creditAccountId) ? globalThis.Number(object.creditAccountId) : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : undefined,
      transactionType: isSet(object.transactionType) ? transactionTypeFromJSON(object.transactionType) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      referenceNumber: isSet(object.referenceNumber) ? globalThis.String(object.referenceNumber) : undefined,
      voucherNumber: isSet(object.voucherNumber) ? globalThis.String(object.voucherNumber) : undefined,
      voucherDate: isSet(object.voucherDate) ? globalThis.String(object.voucherDate) : undefined,
    };
  },

  toJSON(message: UpdateLedgerTransactionRequest): unknown {
    const obj: any = {};
    if (message.debitAccountId !== undefined) {
      obj.debitAccountId = Math.round(message.debitAccountId);
    }
    if (message.creditAccountId !== undefined) {
      obj.creditAccountId = Math.round(message.creditAccountId);
    }
    if (message.amount !== undefined) {
      obj.amount = message.amount;
    }
    if (message.transactionType !== undefined) {
      obj.transactionType = transactionTypeToJSON(message.transactionType);
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.referenceNumber !== undefined) {
      obj.referenceNumber = message.referenceNumber;
    }
    if (message.voucherNumber !== undefined) {
      obj.voucherNumber = message.voucherNumber;
    }
    if (message.voucherDate !== undefined) {
      obj.voucherDate = message.voucherDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateLedgerTransactionRequest>, I>>(base?: I): UpdateLedgerTransactionRequest {
    return UpdateLedgerTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateLedgerTransactionRequest>, I>>(
    object: I,
  ): UpdateLedgerTransactionRequest {
    const message = createBaseUpdateLedgerTransactionRequest();
    message.debitAccountId = object.debitAccountId ?? undefined;
    message.creditAccountId = object.creditAccountId ?? undefined;
    message.amount = object.amount ?? undefined;
    message.transactionType = object.transactionType ?? undefined;
    message.description = object.description ?? undefined;
    message.referenceNumber = object.referenceNumber ?? undefined;
    message.voucherNumber = object.voucherNumber ?? undefined;
    message.voucherDate = object.voucherDate ?? undefined;
    return message;
  },
};

function createBaseLedgerAccountSummary(): LedgerAccountSummary {
  return {
    totalAccounts: 0,
    accountsByType: {},
    totalDebitBalance: 0,
    totalCreditBalance: 0,
    activeAccounts: 0,
    inactiveAccounts: 0,
  };
}

export const LedgerAccountSummary = {
  encode(message: LedgerAccountSummary, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalAccounts !== 0) {
      writer.uint32(8).int32(message.totalAccounts);
    }
    Object.entries(message.accountsByType).forEach(([key, value]) => {
      LedgerAccountSummary_AccountsByTypeEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.totalDebitBalance !== 0) {
      writer.uint32(29).float(message.totalDebitBalance);
    }
    if (message.totalCreditBalance !== 0) {
      writer.uint32(37).float(message.totalCreditBalance);
    }
    if (message.activeAccounts !== 0) {
      writer.uint32(40).int32(message.activeAccounts);
    }
    if (message.inactiveAccounts !== 0) {
      writer.uint32(48).int32(message.inactiveAccounts);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LedgerAccountSummary {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerAccountSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalAccounts = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = LedgerAccountSummary_AccountsByTypeEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.accountsByType[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.totalDebitBalance = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.totalCreditBalance = reader.float();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.activeAccounts = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.inactiveAccounts = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerAccountSummary {
    return {
      totalAccounts: isSet(object.totalAccounts) ? globalThis.Number(object.totalAccounts) : 0,
      accountsByType: isObject(object.accountsByType)
        ? Object.entries(object.accountsByType).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      totalDebitBalance: isSet(object.totalDebitBalance) ? globalThis.Number(object.totalDebitBalance) : 0,
      totalCreditBalance: isSet(object.totalCreditBalance) ? globalThis.Number(object.totalCreditBalance) : 0,
      activeAccounts: isSet(object.activeAccounts) ? globalThis.Number(object.activeAccounts) : 0,
      inactiveAccounts: isSet(object.inactiveAccounts) ? globalThis.Number(object.inactiveAccounts) : 0,
    };
  },

  toJSON(message: LedgerAccountSummary): unknown {
    const obj: any = {};
    if (message.totalAccounts !== 0) {
      obj.totalAccounts = Math.round(message.totalAccounts);
    }
    if (message.accountsByType) {
      const entries = Object.entries(message.accountsByType);
      if (entries.length > 0) {
        obj.accountsByType = {};
        entries.forEach(([k, v]) => {
          obj.accountsByType[k] = Math.round(v);
        });
      }
    }
    if (message.totalDebitBalance !== 0) {
      obj.totalDebitBalance = message.totalDebitBalance;
    }
    if (message.totalCreditBalance !== 0) {
      obj.totalCreditBalance = message.totalCreditBalance;
    }
    if (message.activeAccounts !== 0) {
      obj.activeAccounts = Math.round(message.activeAccounts);
    }
    if (message.inactiveAccounts !== 0) {
      obj.inactiveAccounts = Math.round(message.inactiveAccounts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedgerAccountSummary>, I>>(base?: I): LedgerAccountSummary {
    return LedgerAccountSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedgerAccountSummary>, I>>(object: I): LedgerAccountSummary {
    const message = createBaseLedgerAccountSummary();
    message.totalAccounts = object.totalAccounts ?? 0;
    message.accountsByType = Object.entries(object.accountsByType ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    message.totalDebitBalance = object.totalDebitBalance ?? 0;
    message.totalCreditBalance = object.totalCreditBalance ?? 0;
    message.activeAccounts = object.activeAccounts ?? 0;
    message.inactiveAccounts = object.inactiveAccounts ?? 0;
    return message;
  },
};

function createBaseLedgerAccountSummary_AccountsByTypeEntry(): LedgerAccountSummary_AccountsByTypeEntry {
  return { key: "", value: 0 };
}

export const LedgerAccountSummary_AccountsByTypeEntry = {
  encode(message: LedgerAccountSummary_AccountsByTypeEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LedgerAccountSummary_AccountsByTypeEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerAccountSummary_AccountsByTypeEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerAccountSummary_AccountsByTypeEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: LedgerAccountSummary_AccountsByTypeEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedgerAccountSummary_AccountsByTypeEntry>, I>>(
    base?: I,
  ): LedgerAccountSummary_AccountsByTypeEntry {
    return LedgerAccountSummary_AccountsByTypeEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedgerAccountSummary_AccountsByTypeEntry>, I>>(
    object: I,
  ): LedgerAccountSummary_AccountsByTypeEntry {
    const message = createBaseLedgerAccountSummary_AccountsByTypeEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseLedgerTransactionSummary(): LedgerTransactionSummary {
  return {
    totalTransactions: 0,
    totalDebitAmount: 0,
    totalCreditAmount: 0,
    transactionsByType: {},
    transactionsByMonth: {},
  };
}

export const LedgerTransactionSummary = {
  encode(message: LedgerTransactionSummary, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalTransactions !== 0) {
      writer.uint32(8).int32(message.totalTransactions);
    }
    if (message.totalDebitAmount !== 0) {
      writer.uint32(21).float(message.totalDebitAmount);
    }
    if (message.totalCreditAmount !== 0) {
      writer.uint32(29).float(message.totalCreditAmount);
    }
    Object.entries(message.transactionsByType).forEach(([key, value]) => {
      LedgerTransactionSummary_TransactionsByTypeEntry.encode({ key: key as any, value }, writer.uint32(34).fork())
        .ldelim();
    });
    Object.entries(message.transactionsByMonth).forEach(([key, value]) => {
      LedgerTransactionSummary_TransactionsByMonthEntry.encode({ key: key as any, value }, writer.uint32(42).fork())
        .ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LedgerTransactionSummary {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerTransactionSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalTransactions = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.totalDebitAmount = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.totalCreditAmount = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = LedgerTransactionSummary_TransactionsByTypeEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.transactionsByType[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = LedgerTransactionSummary_TransactionsByMonthEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.transactionsByMonth[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerTransactionSummary {
    return {
      totalTransactions: isSet(object.totalTransactions) ? globalThis.Number(object.totalTransactions) : 0,
      totalDebitAmount: isSet(object.totalDebitAmount) ? globalThis.Number(object.totalDebitAmount) : 0,
      totalCreditAmount: isSet(object.totalCreditAmount) ? globalThis.Number(object.totalCreditAmount) : 0,
      transactionsByType: isObject(object.transactionsByType)
        ? Object.entries(object.transactionsByType).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      transactionsByMonth: isObject(object.transactionsByMonth)
        ? Object.entries(object.transactionsByMonth).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: LedgerTransactionSummary): unknown {
    const obj: any = {};
    if (message.totalTransactions !== 0) {
      obj.totalTransactions = Math.round(message.totalTransactions);
    }
    if (message.totalDebitAmount !== 0) {
      obj.totalDebitAmount = message.totalDebitAmount;
    }
    if (message.totalCreditAmount !== 0) {
      obj.totalCreditAmount = message.totalCreditAmount;
    }
    if (message.transactionsByType) {
      const entries = Object.entries(message.transactionsByType);
      if (entries.length > 0) {
        obj.transactionsByType = {};
        entries.forEach(([k, v]) => {
          obj.transactionsByType[k] = Math.round(v);
        });
      }
    }
    if (message.transactionsByMonth) {
      const entries = Object.entries(message.transactionsByMonth);
      if (entries.length > 0) {
        obj.transactionsByMonth = {};
        entries.forEach(([k, v]) => {
          obj.transactionsByMonth[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedgerTransactionSummary>, I>>(base?: I): LedgerTransactionSummary {
    return LedgerTransactionSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedgerTransactionSummary>, I>>(object: I): LedgerTransactionSummary {
    const message = createBaseLedgerTransactionSummary();
    message.totalTransactions = object.totalTransactions ?? 0;
    message.totalDebitAmount = object.totalDebitAmount ?? 0;
    message.totalCreditAmount = object.totalCreditAmount ?? 0;
    message.transactionsByType = Object.entries(object.transactionsByType ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    message.transactionsByMonth = Object.entries(object.transactionsByMonth ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseLedgerTransactionSummary_TransactionsByTypeEntry(): LedgerTransactionSummary_TransactionsByTypeEntry {
  return { key: "", value: 0 };
}

export const LedgerTransactionSummary_TransactionsByTypeEntry = {
  encode(
    message: LedgerTransactionSummary_TransactionsByTypeEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LedgerTransactionSummary_TransactionsByTypeEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerTransactionSummary_TransactionsByTypeEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerTransactionSummary_TransactionsByTypeEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: LedgerTransactionSummary_TransactionsByTypeEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedgerTransactionSummary_TransactionsByTypeEntry>, I>>(
    base?: I,
  ): LedgerTransactionSummary_TransactionsByTypeEntry {
    return LedgerTransactionSummary_TransactionsByTypeEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedgerTransactionSummary_TransactionsByTypeEntry>, I>>(
    object: I,
  ): LedgerTransactionSummary_TransactionsByTypeEntry {
    const message = createBaseLedgerTransactionSummary_TransactionsByTypeEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseLedgerTransactionSummary_TransactionsByMonthEntry(): LedgerTransactionSummary_TransactionsByMonthEntry {
  return { key: "", value: 0 };
}

export const LedgerTransactionSummary_TransactionsByMonthEntry = {
  encode(
    message: LedgerTransactionSummary_TransactionsByMonthEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LedgerTransactionSummary_TransactionsByMonthEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerTransactionSummary_TransactionsByMonthEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerTransactionSummary_TransactionsByMonthEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: LedgerTransactionSummary_TransactionsByMonthEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedgerTransactionSummary_TransactionsByMonthEntry>, I>>(
    base?: I,
  ): LedgerTransactionSummary_TransactionsByMonthEntry {
    return LedgerTransactionSummary_TransactionsByMonthEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedgerTransactionSummary_TransactionsByMonthEntry>, I>>(
    object: I,
  ): LedgerTransactionSummary_TransactionsByMonthEntry {
    const message = createBaseLedgerTransactionSummary_TransactionsByMonthEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
